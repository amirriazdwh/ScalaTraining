package org.apache.sqoop.manager.oracle

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Constants for OraOop.
 */
object OraOopConstants {
  val ORAOOP_PRODUCT_NAME = "Data Connector for Oracle and Hadoop"
  val ORAOOP_JAR_FILENAME = "oraoop.jar"
  // Disables OraOop - falling back to the OracleManager inside Sqoop...
  val ORAOOP_DISABLED = "oraoop.disabled"
  // Whether to log Oracle session statistics using Guy Harrison's jar file...
  val ORAOOP_REPORT_SESSION_STATISTICS = "oraoop.report.session.statistics"
  // Disables dynamic JDBC URL generation for each mapper...
  val ORAOOP_JDBC_URL_VERBATIM = "oraoop.jdbc.url.verbatim"
  // The name of the Oracle RAC service each mapper should connect to, via their
  // dynamically generated JDBC URL...
  val ORAOOP_ORACLE_RAC_SERVICE_NAME = "oraoop.oracle.rac.service.name"
  // The log4j log-level for OraOop...
  val ORAOOP_LOGGING_LEVEL = "oraoop.logging.level"
  // The file names for the configuration properties of OraOop...
  val ORAOOP_SITE_TEMPLATE_FILENAME = "oraoop-site-template.xml"
  val ORAOOP_SITE_FILENAME = "oraoop-site.xml"
  // The SYSDATE from the Oracle database when this OraOop job was started.
  // This is used to generate unique names for partitions and temporary tables
  // that we create during the job...
  val ORAOOP_JOB_SYSDATE = "oraoop.job.sysdate"
  // The properties are used internally by OraOop to indicate the schema and
  // name of
  // the table being imported/exported...
  val ORAOOP_TABLE_OWNER = "oraoop.table.owner"
  val ORAOOP_TABLE_NAME = "oraoop.table.name"
  // Constants used to indicate the desired location of the WHERE clause within
  // the SQL generated by the record-reader.
  // E.g. A WHERE clause like "rownum <= 10" would want to be located so that
  // it had an impact on the total number of rows returned by the split;
  // as opposed to impacting the number of rows returned for each of the
  // unioned data-chunks within each split.
  val ORAOOP_TABLE_IMPORT_WHERE_CLAUSE_LOCATION = "oraoop.table.import.where.clause.location"

  /**
   * Location to place the WHERE clause.
   */
  object OraOopTableImportWhereClauseLocation extends Enumeration {
    type OraOopTableImportWhereClauseLocation = Value
    val SUBSPLIT, SPLIT = Value
  }

  // The SQL statements to execute for each new Oracle session that is
  // created...
  val ORAOOP_SESSION_INITIALIZATION_STATEMENTS = "oraoop.oracle.session.initialization.statements"
  // Reliably stores the number mappers requested for the sqoop map-reduce
  // job...
  val ORAOOP_DESIRED_NUMBER_OF_MAPPERS = "oraoop.desired.num.mappers"
  // The minimum number of mappers required for OraOop to accept the import
  val ORAOOP_MIN_IMPORT_MAPPERS = "oraoop.min.import.mappers"
  val MIN_NUM_IMPORT_MAPPERS_ACCEPTED_BY_ORAOOP = 2
  // The minimum number of mappers required for OraOop to accept the export
  val ORAOOP_MIN_EXPORT_MAPPERS = "oraoop.min.export.mappers"
  val MIN_NUM_EXPORT_MAPPERS_ACCEPTED_BY_ORAOOP = 2
  // The query used to fetch oracle data chunks...
  val ORAOOP_ORACLE_DATA_CHUNKS_QUERY = "oraoop.oracle.data.chunks.query"
  // The minimum number of active instances in an Oracle RAC required for OraOop
  // to use dynamically generated JDBC URLs...
  val ORAOOP_MIN_RAC_ACTIVE_INSTANCES = "oraoop.min.rac.active.instances"
  val MIN_NUM_RAC_ACTIVE_INSTANCES_FOR_DYNAMIC_JDBC_URLS = 2
  // The name of the Oracle JDBC class...
  val ORACLE_JDBC_DRIVER_CLASS = "oracle.jdbc.OracleDriver"
  // How many rows to pre-fetch when executing Oracle queries...
  val ORACLE_ROW_FETCH_SIZE = "oracle.row.fetch.size"
  val ORACLE_ROW_FETCH_SIZE_DEFAULT = 5000
  // OraOop does not require a "--split-by" column to be defined...
  val TABLE_SPLIT_COLUMN_NOT_REQUIRED = "not-required"
  // The name of the data_chunk_id column the OraOop appends to each (import)
  // query...
  val COLUMN_NAME_DATA_CHUNK_ID = "data_chunk_id"
  // The hint that will be used on the SELECT statement for import jobs
  val IMPORT_QUERY_HINT = "oraoop.import.hint"
  // Pseudo-columns added to an partitioned export table (created by OraOop from
  // a template table)
  // to store the partition value and subpartition value. The partition value is
  // the sysdate when
  // the job was performed. The subpartition value is the mapper index...
  val COLUMN_NAME_EXPORT_PARTITION = "ORAOOP_EXPORT_SYSDATE"
  val COLUMN_NAME_EXPORT_SUBPARTITION = "ORAOOP_MAPPER_ID"
  val COLUMN_NAME_EXPORT_MAPPER_ROW = "ORAOOP_MAPPER_ROW"
  val ORAOOP_EXPORT_PARTITION_DATE_VALUE = "oraoop.export.partition.date.value"
  val ORAOOP_EXPORT_PARTITION_DATE_FORMAT = "yyyy-mm-dd hh24:mi:ss"
  // The string we want to pass to dbms_application_info.set_module() via the
  // "module_name" parameter...
  val ORACLE_SESSION_MODULE_NAME = ORAOOP_PRODUCT_NAME
  // The name of the configuration property containing the string we want to
  // pass to
  // dbms_application_info.set_module() via the "action_name" parameter...
  val ORACLE_SESSION_ACTION_NAME = "oraoop.oracle.session.module.action"
  // Boolean whether to do a consistent read based off an SCN
  val ORAOOP_IMPORT_CONSISTENT_READ = "oraoop.import.consistent.read"
  // The SCN number to use for the consistent read - calculated automatically -
  // cannot be overridden
  val ORAOOP_IMPORT_CONSISTENT_READ_SCN = "oraoop.import.consistent.read.scn"
  // The method that will be used to create data chunks - ROWID ranges or
  // partitions
  val ORAOOP_ORACLE_DATA_CHUNK_METHOD = "oraoop.chunk.method"

  /**
   * How should data be split up - by ROWID range, or by partition.
   */
  object OraOopOracleDataChunkMethod extends Enumeration {
    type OraOopOracleDataChunkMethod = Value
    val ROWID, PARTITION = Value
  }

  // List of partitions to be imported, comma seperated list
  val ORAOOP_IMPORT_PARTITION_LIST = "oraoop.import.partitions"
  val ORAOOP_ORACLE_DATA_CHUNK_METHOD_DEFAULT = OraOopOracleDataChunkMethod.ROWID
  // How to allocate data-chunks into splits...
  val ORAOOP_ORACLE_BLOCK_TO_SPLIT_ALLOCATION_METHOD = "oraoop.block.allocation"

  /**
   * How splits should be allocated to the mappers.
   */
  object OraOopOracleBlockToSplitAllocationMethod extends Enumeration {
    type OraOopOracleBlockToSplitAllocationMethod = Value
    val ROUNDROBIN, SEQUENTIAL, RANDOM = Value
  }

  // Whether to omit LOB and LONG columns during an import...
  val ORAOOP_IMPORT_OMIT_LOBS_AND_LONG = "oraoop.import.omit.lobs.and.long"
  // Identifies an existing Oracle table used to create a new table as the
  // destination of a Sqoop export.
  // Hence, use of this property implies that the "-table" does not exist in
  // Oracle and OraOop should create it.
  val ORAOOP_EXPORT_CREATE_TABLE_TEMPLATE = "oraoop.template.table"
  // If the table already exists that we want to create, should we drop it?...
  val ORAOOP_EXPORT_CREATE_TABLE_DROP = "oraoop.drop.table"
  // If ORAOOP_EXPORT_CREATE_TABLE_TEMPLATE has been specified, then this flag
  // indicates whether the created Oracle
  // tables should have NOLOGGING...
  val ORAOOP_EXPORT_CREATE_TABLE_NO_LOGGING = "oraoop.no.logging"
  // tables should be partitioned by job and mapper...
  val ORAOOP_EXPORT_CREATE_TABLE_PARTITIONED = "oraoop.partitioned"
  // Indicates (internally) the the export table we're dealling with has been
  // paritioned by OraOop...
  val EXPORT_TABLE_HAS_ORAOOP_PARTITIONS = "oraoop.export.table.has.oraoop.partitions"
  // When using the Oracle hint... /* +APPEND_VALUES */ ...a commit must be
  // performed after each batch insert.
  // Therefore, the batches need to be quite large to avoid a performance
  // penality (for the 'extra' commits).
  // This is the minimum batch size to use under these conditions...
  val ORAOOP_MIN_APPEND_VALUES_BATCH_SIZE = "oraoop.min.append.values.batch.size"
  val ORAOOP_MIN_APPEND_VALUES_BATCH_SIZE_DEFAULT = 5000
  // The version of the Oracle database we're connected to...
  val ORAOOP_ORACLE_DATABASE_VERSION_MAJOR = "oraoop.oracle.database.version.major"
  val ORAOOP_ORACLE_DATABASE_VERSION_MINOR = "oraoop.oracle.database.version.minor"
  // When OraOop creates a table for a Sqoop export (from a template table) and
  // the table contains partitions,
  // this is the prefix of those partition names. (This also allows us to later
  // identify partitions that OraOop
  // created.)
  val EXPORT_TABLE_PARTITION_NAME_PREFIX = "ORAOOP_"
  // When OraOop creates temporary tables for each mapper during a Sqoop export
  // this is the prefix of table names...
  val EXPORT_MAPPER_TABLE_NAME_PREFIX = "ORAOOP_"
  // The format string used to turn a DATE into a string for use within the
  // names of Oracle objects
  // that we create. For example, temporary tables, table partitions, table
  // subpartitions...
  val ORACLE_OBJECT_NAME_DATE_TO_STRING_FORMAT_STRING = "yyyymmdd_hh24miss"
  // Indicates whether to perform a "merge" operation when performing a Sqoop
  // export.
  // If false, 'insert' statements will be used (i.e. no 'updates')...
  val ORAOOP_EXPORT_MERGE = "oraoop.export.merge"
  // This property allows the user to enable parallelization during exports...
  val ORAOOP_EXPORT_PARALLEL = "oraoop.export.oracle.parallelization.enabled"
  // Flag used to indicate that the Oracle table contains at least one column of
  // type BINARY_DOUBLE...
  val TABLE_CONTAINS_BINARY_DOUBLE_COLUMN = "oraoop.table.contains.binary.double.column"
  // type BINARY_FLOAT...
  val TABLE_CONTAINS_BINARY_FLOAT_COLUMN = "oraoop.table.contains.binary.float.column"
  // The storage clause to append to the end of any CREATE TABLE statements we
  // execute for temporary Oracle tables...
  val ORAOOP_TEMPORARY_TABLE_STORAGE_CLAUSE = "oraoop.temporary.table.storage.clause"
  // execute for permanent (export) Oracle tables...
  val ORAOOP_EXPORT_TABLE_STORAGE_CLAUSE = "oraoop.table.storage.clause"
  // Additional columns to include with the --update-key column...
  val ORAOOP_UPDATE_KEY_EXTRA_COLUMNS = "oraoop.update.key.extra.columns"
  // Should OraOop map Timestamps as java.sql.Timestamp as Sqoop does, or as
  // String
  val ORAOOP_MAP_TIMESTAMP_AS_STRING = "oraoop.timestamp.string"
  val ORAOOP_MAP_TIMESTAMP_AS_STRING_DEFAULT = true
  // This flag allows the user to force use of the APPEND_VALUES Oracle hint
  // either ON, OFF or AUTO...
  val ORAOOP_ORACLE_APPEND_VALUES_HINT_USAGE = "oraoop.oracle.append.values.hint.usage"

  /**
   * Whether to use the append values hint for exports.
   */
  object AppendValuesHintUsage extends Enumeration {
    type AppendValuesHintUsage = Value
    val AUTO, ON, OFF = Value
  }

  // http://download.oracle.com/docs/cd/E11882_01/server.112/e17118/
  //     sql_elements001.htm#i45441
  val SUPPORTED_IMPORT_ORACLE_DATA_TYPES_CLAUSE = "(DATA_TYPE IN (" + // "'BFILE',"+
    "'BINARY_DOUBLE'," + "'BINARY_FLOAT'," + "'BLOB'," + "'CHAR'," + "'CLOB'," + "'DATE'," + "'FLOAT'," + "'LONG'," + // "'LONG RAW',"+
    // "'MLSLABEL',"+
    "'NCHAR'," + "'NCLOB'," + "'NUMBER'," + "'NVARCHAR2'," + "'RAW'," + "'ROWID'," + // "'UNDEFINED',"+
    "'URITYPE'," + // "'UROWID',"+ //<- SqlType = 1111 = "OTHER" Not supported as
    // "AAAAACAADAAAAAEAAF" is being returned as "AAAAAAgADAAAA"
    "'VARCHAR2'" + // <- Columns declared as VARCHAR are listed as VARCHAR2 in
    // dba_tabl_columns
    // "'XMLTYPE',"+
    ")" + " OR DATA_TYPE LIKE 'INTERVAL YEAR(%) TO MONTH'" + " OR DATA_TYPE LIKE 'INTERVAL DAY(%) TO SECOND(%)'" + " OR DATA_TYPE LIKE 'TIMESTAMP(%)'" + " OR DATA_TYPE LIKE 'TIMESTAMP(%) WITH TIME ZONE'" + " OR DATA_TYPE LIKE 'TIMESTAMP(%) WITH LOCAL TIME ZONE'" + ")"
  val SUPPORTED_EXPORT_ORACLE_DATA_TYPES_CLAUSE = "(DATA_TYPE IN (" + "'BINARY_DOUBLE'," + "'BINARY_FLOAT'," + // "'BLOB',"+ //<- Jira: SQOOP-117 Sqoop cannot export LOB data
    "'CHAR'," + // "'CLOB',"+ //<- Jira: SQOOP-117 Sqoop cannot export LOB data
    "'DATE'," + "'FLOAT'," + // "'LONG',"+ //<- "create table as select..." and
    // "insert into table as select..." do not work when a long column
    // exists.
    "'NCHAR'," + // "'NCLOB',"+ //<- Jira: SQOOP-117 Sqoop cannot export LOB data
    "'NUMBER'," + "'NVARCHAR2'," + // "'RAW',"+
    "'ROWID'," + "'URITYPE'," + "'VARCHAR2'" + ")" + " OR DATA_TYPE LIKE 'INTERVAL YEAR(%) TO MONTH'" + " OR DATA_TYPE LIKE 'INTERVAL DAY(%) TO SECOND(%)'" + " OR DATA_TYPE LIKE 'TIMESTAMP(%)'" + " OR DATA_TYPE LIKE 'TIMESTAMP(%) WITH TIME ZONE'" + " OR DATA_TYPE LIKE 'TIMESTAMP(%) WITH LOCAL TIME ZONE'" + ")"
  // Query to get current logged on user
  val QUERY_GET_SESSION_USER = "SELECT USER FROM DUAL"

  /**
   * Constants for things belonging to sqoop...
   */
  object Sqoop {

    /**
     * What type of Sqoop tool is being run.
     */
    object Tool extends Enumeration {
      type Tool = Value
      val UNKNOWN, IMPORT, EXPORT = Value
    }

    val IMPORT_TOOL_NAME = "import"
    val MAX_MAPREDUCE_ATTEMPTS = "mapred.map.max.attempts"
  }

  final class Sqoop private() {
  }

  /**
   * Constants for things belonging to Oracle...
   */
  object Oracle {
    val ROWID_EXTENDED_ROWID_TYPE = 1
    val ROWID_MAX_ROW_NUMBER_PER_BLOCK = 32767
    // This is how you comment-out a line of SQL text in Oracle.
    val ORACLE_SQL_STATEMENT_COMMENT_TOKEN = "--"
    val OBJECT_TYPE_TABLE = "TABLE"
    val URITYPE = "URITYPE"
    val MAX_IDENTIFIER_LENGTH = 30 // <- Max length of an

    val HINT_SYNTAX = "/*+ %s */ " // Syntax for a hint

  }

  final class Oracle private() {
    // in Oracle
  }

  /**
   * Logging constants.
   */
  object Logging {

    /**
     * Level of log to output.
     */
    object Level extends Enumeration {
      type Level = Value
      val TRACE, DEBUG, INFO, WARN, ERROR, FATAL = Value
    }

  }

}

final class OraOopConstants private() {
}
